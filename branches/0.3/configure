#!/usr/bin/python

import subprocess, sys, tempfile, os, platform, tempfile, shutil

debug = False
profile = False
nogui = False
verbose = False


for arg in sys.argv[1:]:
  if '-debug'.startswith (arg): debug = True
  elif '-profile'.startswith (arg): profile = True
  elif '-nogui'.startswith (arg): nogui = True
  elif '-verbose'.startswith (arg): verbose = True
  else: 
    print """\
usage: [ENV] ./configure [-debug] [-profile] [-nogui]'

In most cases, a simple invocation should work:
   $ ./configure

For non-standard setups, you may need to supply additional
information using environment variables. For example, to set
the compiler, use:
   $ CXX=/usr/local/bin/g++-4.1 ./configure

The '-debug' option will produce a configuration with debug symbols enabled.

The '-profile' option will produce a configuration with profiling enabled.
      note: this will also enable the -debug option.

The '-nogui' option will produce a configuration without any GUI components.

The '-verbose' option will cause configure to output more information.


The following environment variables can be set:

CXX             The compiler command-line to use. The default is:
                "g++ -c CFLAGS SRC -o OBJECT"

LD              The linker command-line to use. The default is:
                "g++ LDFLAGS OBJECTS -o EXECUTABLE"

LDLIB           The linker command-line to use for generating a shared library.
                The default is:
                "g++ -shared LDLIB_FLAGS OBJECTS -o LIB"

CFLAGS          Any additional flags to the compiler.

LDFLAGS         Any additional flags to the linker.

LDLIB_FLAGS     Any additional flags to the linker to generate a shared library.

PTHREAD_CFLAGS  Any flags required to compile with POSIX threads.

PTHREAD_LDFLAGS Any flags required to link with POSIX threads.

GSL_CFLAGS      Any flags required to compile with the GSL.
                This may include in particular the path to the
                include files, if not in a standard location
                For example:
                $ GSL_CFLAGS="-I/usr/local/include" ./configure

GSL_LDFLAGS     Any flags required to link with the GSL.
                This may include in particular the path to the
                libraries, if not in a standard location
                For example:
                $ GSL_LDFLAGS="-L/usr/local/lib -lgsl -lgslcblas" ./configure

ZLIB_CFLAGS     Any flags required to compile with the zlib compression library.

ZLIB_LDFLAGS    Any flags required to link with the zlib compression library.

CBLAS_LDFLAGS   Any flags required to link with an alternate cblas library.

PATH            Set the path to use during the configure process.
                This may be useful to set the path to GTK pkg-config.
                For example:
                $ PATH=/usr/local/bin:$PATH ./configure

                Note that this path will NOT be used during the build
                process itself.
"""
    sys.exit (0)
  


print ''
print 'MRtrix build type requested:',
if profile: print 'profiling',
elif debug: print 'debug',
else: print 'release',
if nogui: print '[command-line only]'
else: print ''
print ''




global cpp, cpp_cmd, ld, ld_cmd

cpp = 'g++ -c CFLAGS SRC -o OBJECT'.split()
cpp_flags = [ '-fPIC' ]

ld = 'g++ LDFLAGS OBJECTS -o EXECUTABLE'.split()
ld_flags = []

ld_lib = 'g++ -shared LDLIB_FLAGS OBJECTS -o LIB'.split()
ld_lib_flags = []

thread_cflags = []
thread_ldflags = [ '-lpthread' ]

zlib_cflags = []
zlib_ldflags = [ '-lz' ]

gsl_cflags = []
gsl_ldflags = [ '-lgsl', '-lgslcblas' ]



class QMakeError: pass
class QMOCError: pass
class CompileError: pass
class LinkError: pass
class RuntimeError: pass

def commit (name, variable):
  cache.write (name + ' = ')
  if type (variable) == type([]): 
    cache.write ('[')
    if len(variable): cache.write(' \'' + '\', \''.join (variable) + '\' ')
    cache.write (']\n')
  else: cache.write ('\'' + variable + '\'\n')



def fillin (template, keyvalue):
  cmd = []
  for item in template:
    if item in keyvalue: 
      if type(keyvalue[item]) == type ([]): cmd += keyvalue[item]
      else: cmd += [ keyvalue[item] ]
    else: cmd += [ item ]
  return cmd


def compile (source, compiler_flags = [], linker_flags = []):
  global cpp, ld
  if verbose: 
    print 'source file:'
    print '---'
    print source
    print '---'
    print ''
  fid = tempfile.NamedTemporaryFile ('w', suffix='.cpp')
  fid.write (source)
  fid.flush()
  obj_name = fid.name[:-4] + '.o'
  cmd = fillin (cpp, {
    'CFLAGS': compiler_flags,
    'SRC': fid.name,
    'OBJECT': obj_name })
  if verbose:
    print 'executing "' + ' '.join(cmd) + '"...'
    print ''
  try: process = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  except OSError: raise CompileError
  if process.wait() != 0: raise CompileError

  cmd = fillin (ld, {
    'LDFLAGS': linker_flags,
    'OBJECTS': obj_name,
    'EXECUTABLE': 'a.out' })
  if verbose:
    print 'executing "' + ' '.join(cmd) + '"...'
    print ''
  try: process = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  except OSError: raise LinkError
  status = process.wait()
  os.unlink (obj_name)
  if status != 0: raise LinkError

  if verbose:
    print 'executing command...'
    print ''
  process = subprocess.Popen ([ './a.out' ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  status = process.wait()
  os.unlink ('a.out')
  if status != 0: raise RuntimeError

  return process.stdout.read()









# set CPP compiler:

if 'CXX' in os.environ.keys(): cpp = os.environ['CXX'].split()
if 'LD' in os.environ.keys(): ld = os.environ['LD'].split()
if 'LDLIB' in os.environ.keys(): ld_lib = os.environ['LDLIB'].split()

print 'Checking C++ compiler [' + cpp[0] + ']:',
sys.stdout.flush()
try: 
  process = subprocess.Popen ([ cpp[0], '-dumpversion' ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  process.wait()
  compiler_version = process.stdout.read().strip()
  if len(compiler_version) == 0: print '(no version information)',
  else: print compiler_version,
  sys.stdout.flush()
  compile ('int main() { return (0); }')
  print '- tested ok'
except CompileError:
  print '''compiler error!

Use CXX environment variable to set path to compiler, as follows:
     CXX=/usr/bin/g++-4.2 ./configure.py'''
except (LinkError, RuntimeError):
  print '''linking error!

Use LD environment variable to set path to compiler, as follows:
     LD=/usr/bin/g++-4.2 ./configure.py'''
  sys.exit (1)




# CPP flags:

if 'CFLAGS' in os.environ.keys(): cpp_flags = os.environ['CFLAGS'].split()
if 'LDFLAGS' in os.environ.keys(): ld_flags = os.environ['LDFLAGS'].split()
if 'LDLIB_FLAGS' in os.environ.keys(): ld_lib_flags = os.environ['LDLIB_FLAGS'].split()


# OS-dependent variables:

obj_suffix = '.o'
exe_suffix = ''
lib_prefix = 'lib'
lib_suffix = '.so'
gl_cflags = []

print 'Detecting OS:',
sys.stdout.flush()
system = platform.system().lower()
print system
if system == 'linux':
  gl_cflags = [ '-DGL_GLEXT_PROTOTYPES' ]
elif system == 'windows':
  cpp_flags += [ '-DWINDOWS', '-mno-cygwin', '-mms-bitfields' ]
  exe_suffix = '.exe'
  lib_prefix = ''
  lib_suffix = '.dll'
elif system == 'darwin':
  cpp_flags += [ '-DMACOSX', '-fPIC' ]
  ld_flags += [ '-dynamiclib' ]
  lib_suffix = '.dylib'




print 'Detecting machine architecture:',
sys.stdout.flush()
march = platform.machine()
if march == 'x86_64': march = 'x86-64'
elif march == 'i686': pass
elif march == 'i586': pass
else: march = None

if march: 
  print march
  cpp_flags += [ '-march='+march ]
else:
  print 'unknown'





print 'Detecting pointer size:',
sys.stdout.flush()
try:
  pointer_size = int (compile ('''
#include <iostream>
int main() { 
  std::cout << sizeof(void*); 
  return (0);
}
'''))
  print 8*pointer_size, 'bit'
  if pointer_size == 8: cpp_flags += [ '-DWORD64' ]
  elif pointer_size != 4: 
    print 'unexpected pointer size!'
    print ''
    sys.exit(1)
except:
  print 'unable to determine pointer size!'
  print ''
  sys.exit(1)




print 'Detecting byte order:',
sys.stdout.flush()
if sys.byteorder == 'big':
  print 'big-endian'
  cpp_flags += [ '-DBYTE_ORDER_IS_BIG_ENDIAN' ]
else:
  print 'little-endian'



print 'Checking for C++ TR1 implementation:',
sys.stdout.flush()
try:
  compile ('''
#include <tr1/unordered_map>

int main() { 
  std::tr1::unordered_map<int,int> map; 
  return (map.size());
}
''')
  print 'present'
  cpp_flags += [ '-DUSE_TR1' ]
except:
  print 'not present - using SGI hash_map instead'




print 'Checking for large file support:',
sys.stdout.flush()
try:
  compile ('''
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int main() { 
  off64_t t = 0; 
  return (t); 
}
''')
  cpp_flags += [ '-DHAVE_LARGE_FILE_SUPPORT' ]
  print 'yes'
except:
  print 'no'




# zlib:

print 'Checking for zlib compression library:',
sys.stdout.flush()

if 'ZLIB_CFLAGS' in os.environ.keys(): zlib_cflags = os.environ['ZLIB_CFLAGS'].split()
if 'ZLIB_LDFLAGS' in os.environ.keys(): zlib_ldflags = os.environ['ZLIB_LDFLAGS'].split()

try:
  zlib_version = compile ('''
#include <iostream>
#include <zlib.h>

int main() { 
  std::cout << zlibVersion(); 
  return (0);
}
''', zlib_cflags, zlib_ldflags)
  print zlib_version
except CompileError:
  print '''compiler error!

Use the ZLIB_CFLAGS environment variable to set the path to
the zlib include files and to set any required flags
For example:
     ZLIB_CFLAGS="-I/usr/local/include" ./configure.py'''
  sys.exit (1)
except LinkError:
  print '''linker error!

Use the ZLIB_LDFLAGS environment variable to set the path to
the zlib libraries and to set the library to use
For example:
     ZLIB_LDFLAGS="-L/usr/local/lib -lz" ./configure.py'''
  sys.exit (1)
except RuntimeError:
  print '''runtime error!

There is something wrong with your zlib implementation!'''
  sys.exit (1)
except:
  print 'not found!'

cpp_flags += zlib_cflags
ld_flags += zlib_ldflags
ld_lib_flags += zlib_ldflags





# POSIX threads:

print 'Checking for POSIX threads:',
sys.stdout.flush()

if 'PTHREAD_CFLAGS' in os.environ.keys(): pthread_cflags = os.environ['PTHREAD_CFLAGS'].split()
if 'PTHREAD_LDFLAGS' in os.environ.keys(): pthread_ldflags = os.environ['PTHREAD_LDFLAGS'].split()

try:
  compile ('''
#include <pthread.h>

void* func (void*) { return (NULL); } 

int main() { 
  pthread_t t; 
  if (pthread_create(&t, NULL, func, NULL)) return (1);
  pthread_exit (NULL); 
  return (0); 
}
''', thread_cflags, thread_ldflags)
  print 'yes'
except CompileError:
  print '''compiler error!

Use the PTHREAD_CFLAGS environment variable to set the path to
the pthread include files and to set any required flags
For example:
     PTHREAD_CFLAGS="-I/usr/local/include" ./configure.py'''
  sys.exit (1)
except LinkError:
  print '''linker error!

Use the PTHREAD_LDFLAGS environment variable to set the path to
the pthread libraries and to set the library to use
For example:
     PTHREAD_LDFLAGS="-L/usr/local/lib -lpthread" ./configure.py'''
  sys.exit (1)
except RuntimeError:
  print '''runtime error!

There is something wrong with your POSIX threads implementation!'''
  sys.exit (1)
except:
  print 'not found!'




# GSL flags:

print 'Checking for GNU Scientific Library:', 
sys.stdout.flush()
if 'GSL_CFLAGS' in os.environ.keys(): gsl_cflags = os.environ['GSL_CFLAGS'].split()
if 'GSL_LDFLAGS' in os.environ.keys(): gsl_ldflags = os.environ['GSL_LDFLAGS'].split()

try:
  gsl_version = compile ('''
#include <iostream>
#include <gsl/gsl_version.h>
#include <gsl/gsl_matrix.h>

int main() { 
  std::cout << gsl_version; 
  gsl_matrix* M = gsl_matrix_alloc (3,3); 
  return (M->size1 != 3);
}
''', gsl_cflags, gsl_ldflags)
  print gsl_version
except CompileError:
  print '''compiler error!

Use the GSL_CFLAGS environment variable to set the path to the GSL include files'
For example:'
     GSL_CFLAGS=-I/usr/local/include ./configure.py'''
  sys.exit (1)
except LinkError:
  print '''linker error!'

Use the GSL_LDFLAGS environment variable to set the path to the GSL libraries'
and include any required libraries'
For example:'
     GSL_LDFLAGS="-L/usr/local/lib -lgsl -lgslcblas" ./configure.py'''
  sys.exit (1)



print 'Checking whether GSL compiles with -DHAVE_INLINE:', 
sys.stdout.flush()
try:
  gsl_version = compile ('#include <gsl/gsl_matrix.h>\nint main() { gsl_matrix* M = gsl_matrix_alloc (3,3); gsl_matrix_set(M,0,0,3.14); return (gsl_matrix_get(M,0,0) != 3.14); }', gsl_cflags + [ '-DHAVE_INLINE' ], gsl_ldflags)
  gsl_cflags += [ '-DHAVE_INLINE' ]
  print 'yes'
except:
  print 'no'




# check for alternate cblas libraries:

if 'CBLAS_LDFLAGS' in os.environ.keys(): 
  cblas_ldflags = os.environ['CBLAS_LDFLAGS'].split()
  flags = gsl_ldflags[:]
  flags.remove ('-lgslcblas')
  flags += cblas_ldflags;
  print 'Checking whether GSL compiles with alternate C BLAS libraries ("' + ' '.join(cblas_ldflags) + '"):',
  try:
    compile ('''
#include <iostream>
#include <gsl/gsl_version.h>
#include <gsl/gsl_matrix.h>

int main() { 
  std::cout << gsl_version; 
  gsl_matrix* M = gsl_matrix_alloc (3,3); 
  return (M->size1 != 3);
}
''', gsl_cflags, flags)
    print 'yes'
    gsl_ldflags = flags
  except:
    print '''no

Error compiling and/or linking with alternative C BLAS libraries provided!
Check whether the information provided by the CBLAS_LDFLAGS environment
variable is correct.'''
    sys.exit (1)







# shared library generation:

print 'Checking shared library generation:',
sys.stdout.flush()

fid = tempfile.NamedTemporaryFile ('w', suffix='.cpp')
fid.write ('int bogus() { return (1); }')
fid.flush()
obj_name = fid.name[:-4] + '.o'
cmd = fillin (cpp, {
  'CFLAGS': cpp_flags,
  'SRC': fid.name,
  'OBJECT': obj_name })
#print ' '.join(cmd)
try: process = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
except OSError:
  print '''compiler not found!

an unexpected error occurred'''
  sys.exit (1)
if process.wait() != 0: 
  print '''compiler error!

an unexpected error occurred'''

libname = lib_prefix + 'test' + lib_suffix
cmd = fillin (ld_lib, {
  'LDLIB_FLAGS': ld_lib_flags,
  'OBJECTS': obj_name,
  'LIB': libname })
#print ' '.join(cmd)
try: process = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
except OSError: 
  print '''linker not found!

Use the LDLIB environment variable to set the command-line
for shared library generation'''
  sys.exit (1)
status = process.wait()
os.unlink (obj_name)
if status != 0:
  print '''linker error!

Use the LDLIB_FLAGS environment variable to set the flags required
for shared library generation'''
  sys.exit (1)

os.unlink (libname)
print 'yes'



qt_cflags = []
qt_ldflags = []


if not nogui:

  print 'Checking for Qt:',
  sys.stdout.flush()

  try:
    qt_dir = tempfile.mkdtemp ();

    f=open (os.path.join (qt_dir, 'qt.h'), 'w')
    f.write ('''
#include <QObject>

class Foo: public QObject {
  Q_OBJECT;
  public:
    Foo();
    ~Foo();
  public slots:
    void setValue(int value);
  signals:
    void valueChanged (int newValue);
  private:
    int value_;
};
''')
    f.close();

    f=open (os.path.join (qt_dir, 'qt.cpp'), 'w')
    f.write ('''
#include <iostream>
#include "qt.h"

Foo::Foo() : value_ (42) { connect (this, SIGNAL(valueChanged(int)), this, SLOT(setValue(int))); }

Foo::~Foo() { std::cout << qVersion() << "\\n"; }

void Foo::setValue (int value) { value_ = value; }

int main() { Foo f; }
'''); 
    f.close();

    f=open (os.path.join (qt_dir, 'qt.pro'), 'w')
    f.write ('CONFIG += qt')
    if debug: f.write (' debug')
    f.write ('\nQT += opengl\nHEADERS += qt.h\nSOURCES += qt.cpp\n')
    f.close();

    try: process = subprocess.Popen ([ 'qmake' ], cwd=qt_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise QMakeError
    if process.wait() != 0: raise QMakeError

    for line in open (os.path.join (qt_dir, 'Makefile')):
      line = line.strip()
      if line.startswith ('DEFINES'):
        qt_defines = line[line.find('=')+1:].strip().split()
      elif line.startswith ('CXXFLAGS'):
        qt_cflags = line[line.find('=')+1:].strip().split()
      elif line.startswith ('INCPATH'):
        qt_includes = line[line.find('=')+1:].strip().split()
      elif line.startswith ('LIBS'):
        qt_libs = line[line.find('=')+1:].strip().split()
      elif line.startswith ('LFLAGS'):
        qt_ldflags = line[line.find('=')+1:].strip().split()

    qt = qt_cflags + qt_defines + qt_includes
    qt_cflags = []
    for entry in qt:
      if entry[0] != '$' and not entry == '-I.': qt_cflags += [ entry ]

    qt = qt_ldflags + qt_libs
    qt_ldflags = []
    for entry in qt:
      if entry[0] != '$': qt_ldflags += [ entry ]

    try: process = subprocess.Popen ([ 'moc-qt4', 'qt.h', '-o', 'qt_moc.cpp' ], cwd=qt_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise QMOCError
    if process.wait() != 0: raise QMOCError

    try: process = subprocess.Popen ([ 'g++', '-c' ] + qt_cflags + [ 'qt.cpp', '-o', 'qt.o' ], cwd=qt_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise CompileError
    if process.wait() != 0: raise CompileError

    try: process = subprocess.Popen ([ 'g++', '-c' ] + qt_cflags + [ 'qt_moc.cpp', '-o', 'qt_moc.o' ] , cwd=qt_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise CompileError
    if process.wait() != 0: raise CompileError

    try: process = subprocess.Popen ([ 'g++' ] + qt_ldflags + [ 'qt_moc.o', 'qt.o', '-o', 'qt' ] , cwd=qt_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise LinkError
    if process.wait() != 0: raise LinkError

    process = subprocess.Popen (os.path.join(qt_dir, 'qt'), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if process.wait() != 0: raise LinkError
    print process.stdout.read().strip()

    
  except QMakeError:
    print 'error invoking Qt qmake!'
    sys.exit (1)

  except QMOCError:
    print 'error invoking Qt moc!'
    sys.exit (1)

  except CompileError:
    print 'error compiling Qt application!'
    sys.exit (1)

  except OSError:
    print 'Unexpected error! Unable to configure Qt environment'
    sys.exit (1)

  finally:
    for entry in os.listdir (qt_dir):
      os.remove (os.path.join(qt_dir, entry))
    os.rmdir (qt_dir)



  print 'Checking for OpenGL:',
  sys.stdout.flush()
  qt_cflags += gl_cflags
  try:
    gl_version = compile ('''
#include <QtGui>
#include <QtOpenGL>
#include <QApplication>
#include <QGLWidget>
#include <iostream>

class GLWidget : public QGLWidget {
  public:
    GLWidget (QWidget *parent = 0) : QGLWidget (parent) { }
    ~GLWidget() { }
  protected:
    void initializeGL () { std::cout << glGetString (GL_VERSION) << "\\n"; exit (0); }
    void paintGL () { }
    void resizeGL (int width, int height) { }
};

int main (int argc, char *argv[]) {
  QApplication app (argc, argv);
  GLWidget window;
  window.show();
  return app.exec();
}
''', qt_cflags, qt_ldflags)
    print gl_version.strip()
  except:
    print 'not found!'







# add debugging or profiling flags if requested:

cpp_flags += [ '-D__STDC_LIMIT_MACROS' ]

if profile:
  cpp_flags += [ '-g', '-pg' ]
  ld_flags += [ '-g', '-pg' ]
  ld_lib_flags += [ '-g', '-pg' ]
elif debug:
  cpp_flags += [ '-O0', '-g', '-D_GLIBCXX_DEBUG=1', '-D_GLIBCXX_DEBUG_PEDANTIC=1' ]
  ld_flags += [ '-g' ]
  ld_lib_flags += [ '-g' ]
else:
  cpp_flags += [ '-O2', '-DNDEBUG' ]



# write out configuration:

cache_filename = os.path.join (os.path.dirname(sys.argv[0]), 'configuration.py')

print ''
print 'writing configuration to file \'' + cache_filename + '\':',

cache = open (cache_filename, 'w')
cache.write ('#!/usr/bin/python\n')
cache.write ('# autogenerated by MRtrix configure script\n\n')

commit ('obj_suffix', obj_suffix)
commit ('exe_suffix', exe_suffix)
commit ('lib_prefix', lib_prefix)
commit ('lib_suffix', lib_suffix)
commit ('cpp', cpp);
commit ('cpp_flags', cpp_flags);
commit ('ld', ld);
commit ('ld_flags', ld_flags);
commit ('ld_lib', ld_lib);
commit ('ld_lib_flags', ld_lib_flags);
commit ('thread_cflags', thread_cflags)
commit ('thread_ldflags', thread_ldflags)
commit ('gsl_cflags', gsl_cflags)
commit ('gsl_ldflags', gsl_ldflags)
commit ('qt_cflags', qt_cflags)
commit ('qt_ldflags', qt_ldflags)

cache.close()
print 'ok'
print ''

